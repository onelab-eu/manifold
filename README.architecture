== Flow management

- Flow are unidirectional and only serve when using interfaces that are not
gateways. Currently, we use flow maps for all interfaces.
- In gateways, a system of callbacks is used to keep the packet, and thus the
flow, with the receiver at each step. We might want to use the flow table then ?
That would require the gateway to send the packet, and not to directly target
the receiver as it is done in most of the cases.
- Do we need ACK and NACK packets ? Timeouts in flow table could be answered by
something then, otherwise, sometimes, we might not expect an answer.
- Shall we explicitely specify that we need an answer ?

TODO:
- Colliding flows on Interface::send are currently ignored. Relationship with
cache ? Why should not we be able to forward multiple times the same query ?
What about user permissions, this would be the same flow with different
pipelines then !!!

BIG ISSUE:
- suppose incoming query X
- no answer, expired
- same query again X'
- answer to X arrive, followed by answer to X'
- unconsistent answer
-
- even marking the interface expired, we don't know what to do with packets for X
-
=> we might need to take into account a packet UUID into the flow. Then we
cannot merge two queries anymore...
-
- let's accept corrupted answer for now
! that's the problem of the connected mode !

see: manifold.interfaces



== Packet format

- Required for interoperability of different routers... but also of different
gateways communicating through UNIX socket...
- btw, can we have something that spawn a gateway on demand, for example a
fastping daemon ?
- currently serialization is handled by pickle


== Shell

- Should autoreconnect when restarting the router



== Forwarding

- What about loops ?



== DEMO

- Periodic queries Needed from a demo point of view to instrument something
- Some examples of instrumented tools
- A bit like OML but we can dynamically establish streams ?
- Nodes autoorganize as an overlay
